import{S as zo,i as Io,s as Lo,C as Je,w as bo,x as wo,y as So,z as qo,A as ho,f as Bo,t as Ro,B as Do,P as Po,l,r as s,a as d,m as i,n as r,u as c,h as o,c as f,F as Ze,p as F,b as n,G as t,E as Co}from"../../chunks/index-c6be98ca.js";import{P as Mo}from"../../chunks/_post-bf96fcd3.js";import"../../chunks/helpers-e147ed77.js";import"../../chunks/Categoria.svelte_svelte_type_style_lang-d76a398c.js";function To(b){let p,_,v,g,u,m,E,fe,ee,w,me,oe,S,_e,te,q,ve,le,B,ge,ie,h,I,he,O,Pe,Ee,ze,L,Ie,Z,Le,be,we,R,Se,z,D,J,qe,Be,Re,C,K,De,Ce,Me,M,Q,Te,xe,ae,T,V,$e,re,x,W,ke,ne,$,X,ye,se,k,Ae,ce,y,Y,Ue,pe,P,A,Ke,Ge,U,Qe,He,G,Ve;return{c(){p=l("h3"),_=s("A cosa serve?"),v=d(),g=l("p"),u=s(`Il protocollo Spanning Tree \xE8 un protocollo di rete che consente di creare una topologia di rete fisica loop-free. Lo spanning tree viene utilizzato per
evitare che i pacchetti circolino in loop infiniti all\u2019interno della rete.`),m=d(),E=l("p"),fe=s(`Il protocollo consente di selezionare un percorso principale tra due nodi
qualsiasi all\u2019interno della rete e di inoltrare il traffico di rete solo su questo percorso. Ci\xF2 consente di ridurre il traffico di rete inutile e di
migliorare l\u2019efficienza della rete.`),ee=d(),w=l("h3"),me=s("Il Broadcast storming"),oe=d(),S=l("p"),_e=s(`Il protocollo spanning tree \xE8 anche utilizzato per prevenire gli effetti negativi del broadcast storm. I broadcast storm
si verificano quando un pacchetto viene inoltrato in modo errato e viene inoltrato a tutti i nodi della rete. Ci\xF2 pu\xF2 causare
un sovraccarico di traffico e un\u2019interruzione delle comunicazioni.`),te=d(),q=l("h3"),ve=s("Come funziona lo spanning-tree protocol?"),le=d(),B=l("p"),ge=s("Il funzionamento dello STP si pu\xF2 spiegare per passaggi:"),ie=d(),h=l("ol"),I=l("li"),he=s("Aquisizione dei "),O=l("em"),Pe=s("bridgeID"),Ee=s(" degli switch all\u2019interno della rete."),ze=d(),L=l("li"),Ie=s("Selezione "),Z=l("em"),Le=s("root-bridge"),be=s(` (tutte le porte del root-bridge sono designated-
port)`),we=d(),R=l("li"),Se=s("Identificazione delle porte degli altri switch: "),z=l("ul"),D=l("li"),J=l("em"),qe=s("root-port"),Be=s("(RP)"),Re=d(),C=l("li"),K=l("em"),De=s("designated-port"),Ce=s("(DP)"),Me=d(),M=l("li"),Q=l("em"),Te=s("blocked-port"),xe=s("(BP)"),ae=d(),T=l("ul"),V=l("li"),$e=s("Le RP si identificano dal minor costo del percorso, che dalla porta dello switch interessato raggiunge il RB."),re=d(),x=l("ul"),W=l("li"),ke=s(`Le DP si identificano per esclusione, dato che una delle due porte in un collegamento tra switch (segmento) sar\xE0 o RP o BP, l\u2019altra
dello stesso collegamento sar\xE0 DP. Le porte dei collegamenti che non connettono lo switch ad altri switch
(es. PC, server) sono SEMPRE DP.`),ne=d(),$=l("ul"),X=l("li"),ye=s("Le BP, dette anche \u201Cporte di ridondanza\u201D, sono delle porte dove il passaggio dei frame \xE8 bloccato."),se=d(),k=l("p"),Ae=s(`Per capire quando in
un collegamento tra switch una porta \xE8 blocked e l\u2019altra \xE8 designated bisogna fare questo ragionamento:`),ce=d(),y=l("ul"),Y=l("li"),Ue=s(`si immagina che in un collegamento tra due switch ci sia collegato un computer e che questo voglia raggiungere il RB, quindi,
contando il collegamento a cui \xE8 connesso, inizio a calcolare il percorso col costo minore. Identifico come DP la
porta dello switch che \xE8 connessa al percorso col minor costo, l\u2019altra, invece, la identifico come BP.`),pe=d(),P=l("center"),A=l("img"),Ge=d(),U=l("img"),He=d(),G=l("img"),this.h()},l(e){p=i(e,"H3",{});var a=r(p);_=c(a,"A cosa serve?"),a.forEach(o),v=f(e),g=i(e,"P",{});var We=r(g);u=c(We,`Il protocollo Spanning Tree \xE8 un protocollo di rete che consente di creare una topologia di rete fisica loop-free. Lo spanning tree viene utilizzato per
evitare che i pacchetti circolino in loop infiniti all\u2019interno della rete.`),We.forEach(o),m=f(e),E=i(e,"P",{});var Xe=r(E);fe=c(Xe,`Il protocollo consente di selezionare un percorso principale tra due nodi
qualsiasi all\u2019interno della rete e di inoltrare il traffico di rete solo su questo percorso. Ci\xF2 consente di ridurre il traffico di rete inutile e di
migliorare l\u2019efficienza della rete.`),Xe.forEach(o),ee=f(e),w=i(e,"H3",{});var Ye=r(w);me=c(Ye,"Il Broadcast storming"),Ye.forEach(o),oe=f(e),S=i(e,"P",{});var eo=r(S);_e=c(eo,`Il protocollo spanning tree \xE8 anche utilizzato per prevenire gli effetti negativi del broadcast storm. I broadcast storm
si verificano quando un pacchetto viene inoltrato in modo errato e viene inoltrato a tutti i nodi della rete. Ci\xF2 pu\xF2 causare
un sovraccarico di traffico e un\u2019interruzione delle comunicazioni.`),eo.forEach(o),te=f(e),q=i(e,"H3",{});var oo=r(q);ve=c(oo,"Come funziona lo spanning-tree protocol?"),oo.forEach(o),le=f(e),B=i(e,"P",{});var to=r(B);ge=c(to,"Il funzionamento dello STP si pu\xF2 spiegare per passaggi:"),to.forEach(o),ie=f(e),h=i(e,"OL",{});var H=r(h);I=i(H,"LI",{});var ue=r(I);he=c(ue,"Aquisizione dei "),O=i(ue,"EM",{});var lo=r(O);Pe=c(lo,"bridgeID"),lo.forEach(o),Ee=c(ue," degli switch all\u2019interno della rete."),ue.forEach(o),ze=f(H),L=i(H,"LI",{});var de=r(L);Ie=c(de,"Selezione "),Z=i(de,"EM",{});var io=r(Z);Le=c(io,"root-bridge"),io.forEach(o),be=c(de,` (tutte le porte del root-bridge sono designated-
port)`),de.forEach(o),we=f(H),R=i(H,"LI",{});var Ne=r(R);Se=c(Ne,"Identificazione delle porte degli altri switch: "),z=i(Ne,"UL",{});var N=r(z);D=i(N,"LI",{});var je=r(D);J=i(je,"EM",{});var ao=r(J);qe=c(ao,"root-port"),ao.forEach(o),Be=c(je,"(RP)"),je.forEach(o),Re=f(N),C=i(N,"LI",{});var Fe=r(C);K=i(Fe,"EM",{});var ro=r(K);De=c(ro,"designated-port"),ro.forEach(o),Ce=c(Fe,"(DP)"),Fe.forEach(o),Me=f(N),M=i(N,"LI",{});var Oe=r(M);Q=i(Oe,"EM",{});var no=r(Q);Te=c(no,"blocked-port"),no.forEach(o),xe=c(Oe,"(BP)"),Oe.forEach(o),N.forEach(o),Ne.forEach(o),H.forEach(o),ae=f(e),T=i(e,"UL",{});var so=r(T);V=i(so,"LI",{});var co=r(V);$e=c(co,"Le RP si identificano dal minor costo del percorso, che dalla porta dello switch interessato raggiunge il RB."),co.forEach(o),so.forEach(o),re=f(e),x=i(e,"UL",{});var po=r(x);W=i(po,"LI",{});var uo=r(W);ke=c(uo,`Le DP si identificano per esclusione, dato che una delle due porte in un collegamento tra switch (segmento) sar\xE0 o RP o BP, l\u2019altra
dello stesso collegamento sar\xE0 DP. Le porte dei collegamenti che non connettono lo switch ad altri switch
(es. PC, server) sono SEMPRE DP.`),uo.forEach(o),po.forEach(o),ne=f(e),$=i(e,"UL",{});var fo=r($);X=i(fo,"LI",{});var mo=r(X);ye=c(mo,"Le BP, dette anche \u201Cporte di ridondanza\u201D, sono delle porte dove il passaggio dei frame \xE8 bloccato."),mo.forEach(o),fo.forEach(o),se=f(e),k=i(e,"P",{});var _o=r(k);Ae=c(_o,`Per capire quando in
un collegamento tra switch una porta \xE8 blocked e l\u2019altra \xE8 designated bisogna fare questo ragionamento:`),_o.forEach(o),ce=f(e),y=i(e,"UL",{});var vo=r(y);Y=i(vo,"LI",{});var go=r(Y);Ue=c(go,`si immagina che in un collegamento tra due switch ci sia collegato un computer e che questo voglia raggiungere il RB, quindi,
contando il collegamento a cui \xE8 connesso, inizio a calcolare il percorso col costo minore. Identifico come DP la
porta dello switch che \xE8 connessa al percorso col minor costo, l\u2019altra, invece, la identifico come BP.`),go.forEach(o),vo.forEach(o),pe=f(e),P=i(e,"CENTER",{});var j=r(P);A=i(j,"IMG",{src:!0,alt:!0}),Ge=f(j),U=i(j,"IMG",{src:!0,alt:!0}),He=f(j),G=i(j,"IMG",{src:!0,alt:!0}),j.forEach(o),this.h()},h(){Ze(A.src,Ke="/img/posts/spanning-tree-protocol/schermata1a.webp")||F(A,"src",Ke),F(A,"alt","Schemata1-STP"),Ze(U.src,Qe="/img/posts/spanning-tree-protocol/schermata2a.webp")||F(U,"src",Qe),F(U,"alt","Schemata2-STP"),Ze(G.src,Ve="/img/posts/spanning-tree-protocol/schermata3a.webp")||F(G,"src",Ve),F(G,"alt","Schemata3-STP")},m(e,a){n(e,p,a),t(p,_),n(e,v,a),n(e,g,a),t(g,u),n(e,m,a),n(e,E,a),t(E,fe),n(e,ee,a),n(e,w,a),t(w,me),n(e,oe,a),n(e,S,a),t(S,_e),n(e,te,a),n(e,q,a),t(q,ve),n(e,le,a),n(e,B,a),t(B,ge),n(e,ie,a),n(e,h,a),t(h,I),t(I,he),t(I,O),t(O,Pe),t(I,Ee),t(h,ze),t(h,L),t(L,Ie),t(L,Z),t(Z,Le),t(L,be),t(h,we),t(h,R),t(R,Se),t(R,z),t(z,D),t(D,J),t(J,qe),t(D,Be),t(z,Re),t(z,C),t(C,K),t(K,De),t(C,Ce),t(z,Me),t(z,M),t(M,Q),t(Q,Te),t(M,xe),n(e,ae,a),n(e,T,a),t(T,V),t(V,$e),n(e,re,a),n(e,x,a),t(x,W),t(W,ke),n(e,ne,a),n(e,$,a),t($,X),t(X,ye),n(e,se,a),n(e,k,a),t(k,Ae),n(e,ce,a),n(e,y,a),t(y,Y),t(Y,Ue),n(e,pe,a),n(e,P,a),t(P,A),t(P,Ge),t(P,U),t(P,He),t(P,G)},p:Co,d(e){e&&o(p),e&&o(v),e&&o(g),e&&o(m),e&&o(E),e&&o(ee),e&&o(w),e&&o(oe),e&&o(S),e&&o(te),e&&o(q),e&&o(le),e&&o(B),e&&o(ie),e&&o(h),e&&o(ae),e&&o(T),e&&o(re),e&&o(x),e&&o(ne),e&&o($),e&&o(se),e&&o(k),e&&o(ce),e&&o(y),e&&o(pe),e&&o(P)}}}function xo(b){let p,_;const v=[b[0],Eo];let g={$$slots:{default:[To]},$$scope:{ctx:b}};for(let u=0;u<v.length;u+=1)g=Je(g,v[u]);return p=new Mo({props:g}),{c(){bo(p.$$.fragment)},l(u){wo(p.$$.fragment,u)},m(u,m){So(p,u,m),_=!0},p(u,[m]){const E=m&1?qo(v,[m&1&&ho(u[0]),m&0&&ho(Eo)]):{};m&2&&(E.$$scope={dirty:m,ctx:u}),p.$set(E)},i(u){_||(Bo(p.$$.fragment,u),_=!0)},o(u){Ro(p.$$.fragment,u),_=!1},d(u){Do(p,u)}}}const Eo={id:"2022-11-15-12",titolo:"Spanning-tree Protocol",featured:!1,autore:"Luca Bortoluzzi",data:"2022-11-15T00:00:00.000Z",cover:"cover_stpa.webp",introduzione:"Introduzione allo Spanning-tree Protocol",pubblicato:!0,sezione:"Blog",categorie:["Protocols","Technology","Networking","Switching"]};function $o(b,p,_){return b.$$set=v=>{_(0,p=Je(Je({},p),Po(v)))},p=Po(p),[p]}class Go extends zo{constructor(p){super(),Io(this,p,$o,xo,Lo,{})}}export{Go as default,Eo as metadata};
