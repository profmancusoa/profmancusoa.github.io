import{S as wo,i as So,s as qo,C as Ve,w as Bo,x as Ro,y as To,z as Co,A as Io,f as Do,t as Mo,B as xo,P as Lo,l,r as s,a as d,m as i,n as r,u as c,h as o,c as f,F as Qe,p as F,b as n,G as t,E as $o}from"../../chunks/index-13114d8e.js";import{P as No}from"../../chunks/_post-f0361b2b.js";import"../../chunks/helpers-e147ed77.js";import"../../chunks/Categoria.svelte_svelte_type_style_lang-7c2ca554.js";function Ao(b){let p,_,v,g,u,m,E,_e,oe,w,ve,te,S,ge,le,q,he,ie,B,Pe,ae,R,Ee,re,h,I,ze,Z,Ie,Le,be,L,we,J,Se,qe,Be,T,Re,z,C,K,Te,Ce,De,D,Q,Me,xe,$e,M,V,Ne,Ae,ne,x,W,Oe,se,$,X,Ge,ce,N,Y,ke,pe,A,ye,ue,O,ee,Ue,de,P,G,We,He,k,Xe,je,y,Ye;return{c(){p=l("h1"),_=s("SPANNING-TREE PROTOCOL"),v=d(),g=l("h3"),u=s("A cosa serve?"),m=d(),E=l("p"),_e=s(`Il protocollo Spanning Tree \xE8 un protocollo di rete che consente di creare una topologia di rete fisica loop-free. Lo spanning tree viene utilizzato per
evitare che i pacchetti circolino in loop infiniti all\u2019interno della rete.`),oe=d(),w=l("p"),ve=s(`Il protocollo consente di selezionare un percorso principale tra due nodi
qualsiasi all\u2019interno della rete e di inoltrare il traffico di rete solo su questo percorso. Ci\xF2 consente di ridurre il traffico di rete inutile e di
migliorare l\u2019efficienza della rete.`),te=d(),S=l("h3"),ge=s("Il Broadcast storming"),le=d(),q=l("p"),he=s(`Il protocollo spanning tree \xE8 anche utilizzato per prevenire gli effetti negativi del broadcast storm. I broadcast storm
si verificano quando un pacchetto viene inoltrato in modo errato e viene inoltrato a tutti i nodi della rete. Ci\xF2 pu\xF2 causare
un sovraccarico di traffico e un\u2019interruzione delle comunicazioni.`),ie=d(),B=l("h3"),Pe=s("Come funziona lo spanning-tree protocol?"),ae=d(),R=l("p"),Ee=s("Il funzionamento dello STP si pu\xF2 spiegare per passaggi:"),re=d(),h=l("ol"),I=l("li"),ze=s("Aquisizione dei "),Z=l("em"),Ie=s("bridgeID"),Le=s(" degli switch all\u2019interno della rete."),be=d(),L=l("li"),we=s("Selezione "),J=l("em"),Se=s("root-bridge"),qe=s(` (tutte le porte del root-bridge sono designated-
port)`),Be=d(),T=l("li"),Re=s("Identificazione delle porte degli altri switch: "),z=l("ul"),C=l("li"),K=l("em"),Te=s("root-port"),Ce=s("(RP)"),De=d(),D=l("li"),Q=l("em"),Me=s("designated-port"),xe=s("(DP)"),$e=d(),M=l("li"),V=l("em"),Ne=s("blocked-port"),Ae=s("(BP)"),ne=d(),x=l("ul"),W=l("li"),Oe=s("Le RP si identificano dal minor costo del percorso, che dalla porta dello switch interessato raggiunge il RB."),se=d(),$=l("ul"),X=l("li"),Ge=s(`Le DP si identificano per esclusione, dato che una delle due porte in un collegamento tra switch (segmento) sar\xE0 o RP o BP, l\u2019altra
dello stesso collegamento sar\xE0 DP. Le porte dei collegamenti che non connettono lo switch ad altri switch
(es. PC, server) sono SEMPRE DP.`),ce=d(),N=l("ul"),Y=l("li"),ke=s("Le BP, dette anche \u201Cporte di ridondanza\u201D, sono delle porte dove il passaggio dei frame \xE8 bloccato."),pe=d(),A=l("p"),ye=s(`Per capire quando in
un collegamento tra switch una porta \xE8 blocked e l\u2019altra \xE8 designated bisogna fare questo ragionamento:`),ue=d(),O=l("ul"),ee=l("li"),Ue=s(`si immagina che in un collegamento tra due switch ci sia collegato un computer e che questo voglia raggiungere il RB, quindi,
contando il collegamento a cui \xE8 connesso, inizio a calcolare il percorso col costo minore. Identifico come DP la
porta dello switch che \xE8 connessa al percorso col minor costo, l\u2019altra, invece, la identifico come BP.`),de=d(),P=l("center"),G=l("img"),He=d(),k=l("img"),je=d(),y=l("img"),this.h()},l(e){p=i(e,"H1",{});var a=r(p);_=c(a,"SPANNING-TREE PROTOCOL"),a.forEach(o),v=f(e),g=i(e,"H3",{});var eo=r(g);u=c(eo,"A cosa serve?"),eo.forEach(o),m=f(e),E=i(e,"P",{});var oo=r(E);_e=c(oo,`Il protocollo Spanning Tree \xE8 un protocollo di rete che consente di creare una topologia di rete fisica loop-free. Lo spanning tree viene utilizzato per
evitare che i pacchetti circolino in loop infiniti all\u2019interno della rete.`),oo.forEach(o),oe=f(e),w=i(e,"P",{});var to=r(w);ve=c(to,`Il protocollo consente di selezionare un percorso principale tra due nodi
qualsiasi all\u2019interno della rete e di inoltrare il traffico di rete solo su questo percorso. Ci\xF2 consente di ridurre il traffico di rete inutile e di
migliorare l\u2019efficienza della rete.`),to.forEach(o),te=f(e),S=i(e,"H3",{});var lo=r(S);ge=c(lo,"Il Broadcast storming"),lo.forEach(o),le=f(e),q=i(e,"P",{});var io=r(q);he=c(io,`Il protocollo spanning tree \xE8 anche utilizzato per prevenire gli effetti negativi del broadcast storm. I broadcast storm
si verificano quando un pacchetto viene inoltrato in modo errato e viene inoltrato a tutti i nodi della rete. Ci\xF2 pu\xF2 causare
un sovraccarico di traffico e un\u2019interruzione delle comunicazioni.`),io.forEach(o),ie=f(e),B=i(e,"H3",{});var ao=r(B);Pe=c(ao,"Come funziona lo spanning-tree protocol?"),ao.forEach(o),ae=f(e),R=i(e,"P",{});var ro=r(R);Ee=c(ro,"Il funzionamento dello STP si pu\xF2 spiegare per passaggi:"),ro.forEach(o),re=f(e),h=i(e,"OL",{});var U=r(h);I=i(U,"LI",{});var fe=r(I);ze=c(fe,"Aquisizione dei "),Z=i(fe,"EM",{});var no=r(Z);Ie=c(no,"bridgeID"),no.forEach(o),Le=c(fe," degli switch all\u2019interno della rete."),fe.forEach(o),be=f(U),L=i(U,"LI",{});var me=r(L);we=c(me,"Selezione "),J=i(me,"EM",{});var so=r(J);Se=c(so,"root-bridge"),so.forEach(o),qe=c(me,` (tutte le porte del root-bridge sono designated-
port)`),me.forEach(o),Be=f(U),T=i(U,"LI",{});var Fe=r(T);Re=c(Fe,"Identificazione delle porte degli altri switch: "),z=i(Fe,"UL",{});var H=r(z);C=i(H,"LI",{});var Ze=r(C);K=i(Ze,"EM",{});var co=r(K);Te=c(co,"root-port"),co.forEach(o),Ce=c(Ze,"(RP)"),Ze.forEach(o),De=f(H),D=i(H,"LI",{});var Je=r(D);Q=i(Je,"EM",{});var po=r(Q);Me=c(po,"designated-port"),po.forEach(o),xe=c(Je,"(DP)"),Je.forEach(o),$e=f(H),M=i(H,"LI",{});var Ke=r(M);V=i(Ke,"EM",{});var uo=r(V);Ne=c(uo,"blocked-port"),uo.forEach(o),Ae=c(Ke,"(BP)"),Ke.forEach(o),H.forEach(o),Fe.forEach(o),U.forEach(o),ne=f(e),x=i(e,"UL",{});var fo=r(x);W=i(fo,"LI",{});var mo=r(W);Oe=c(mo,"Le RP si identificano dal minor costo del percorso, che dalla porta dello switch interessato raggiunge il RB."),mo.forEach(o),fo.forEach(o),se=f(e),$=i(e,"UL",{});var _o=r($);X=i(_o,"LI",{});var vo=r(X);Ge=c(vo,`Le DP si identificano per esclusione, dato che una delle due porte in un collegamento tra switch (segmento) sar\xE0 o RP o BP, l\u2019altra
dello stesso collegamento sar\xE0 DP. Le porte dei collegamenti che non connettono lo switch ad altri switch
(es. PC, server) sono SEMPRE DP.`),vo.forEach(o),_o.forEach(o),ce=f(e),N=i(e,"UL",{});var go=r(N);Y=i(go,"LI",{});var ho=r(Y);ke=c(ho,"Le BP, dette anche \u201Cporte di ridondanza\u201D, sono delle porte dove il passaggio dei frame \xE8 bloccato."),ho.forEach(o),go.forEach(o),pe=f(e),A=i(e,"P",{});var Po=r(A);ye=c(Po,`Per capire quando in
un collegamento tra switch una porta \xE8 blocked e l\u2019altra \xE8 designated bisogna fare questo ragionamento:`),Po.forEach(o),ue=f(e),O=i(e,"UL",{});var Eo=r(O);ee=i(Eo,"LI",{});var zo=r(ee);Ue=c(zo,`si immagina che in un collegamento tra due switch ci sia collegato un computer e che questo voglia raggiungere il RB, quindi,
contando il collegamento a cui \xE8 connesso, inizio a calcolare il percorso col costo minore. Identifico come DP la
porta dello switch che \xE8 connessa al percorso col minor costo, l\u2019altra, invece, la identifico come BP.`),zo.forEach(o),Eo.forEach(o),de=f(e),P=i(e,"CENTER",{});var j=r(P);G=i(j,"IMG",{src:!0,alt:!0}),He=f(j),k=i(j,"IMG",{src:!0,alt:!0}),je=f(j),y=i(j,"IMG",{src:!0,alt:!0}),j.forEach(o),this.h()},h(){Qe(G.src,We="/img/posts/spanning-tree-protocol/schermata1a.webp")||F(G,"src",We),F(G,"alt","Schemata1-STP"),Qe(k.src,Xe="/img/posts/spanning-tree-protocol/schermata2a.webp")||F(k,"src",Xe),F(k,"alt","Schemata2-STP"),Qe(y.src,Ye="/img/posts/spanning-tree-protocol/schermata3a.webp")||F(y,"src",Ye),F(y,"alt","Schemata3-STP")},m(e,a){n(e,p,a),t(p,_),n(e,v,a),n(e,g,a),t(g,u),n(e,m,a),n(e,E,a),t(E,_e),n(e,oe,a),n(e,w,a),t(w,ve),n(e,te,a),n(e,S,a),t(S,ge),n(e,le,a),n(e,q,a),t(q,he),n(e,ie,a),n(e,B,a),t(B,Pe),n(e,ae,a),n(e,R,a),t(R,Ee),n(e,re,a),n(e,h,a),t(h,I),t(I,ze),t(I,Z),t(Z,Ie),t(I,Le),t(h,be),t(h,L),t(L,we),t(L,J),t(J,Se),t(L,qe),t(h,Be),t(h,T),t(T,Re),t(T,z),t(z,C),t(C,K),t(K,Te),t(C,Ce),t(z,De),t(z,D),t(D,Q),t(Q,Me),t(D,xe),t(z,$e),t(z,M),t(M,V),t(V,Ne),t(M,Ae),n(e,ne,a),n(e,x,a),t(x,W),t(W,Oe),n(e,se,a),n(e,$,a),t($,X),t(X,Ge),n(e,ce,a),n(e,N,a),t(N,Y),t(Y,ke),n(e,pe,a),n(e,A,a),t(A,ye),n(e,ue,a),n(e,O,a),t(O,ee),t(ee,Ue),n(e,de,a),n(e,P,a),t(P,G),t(P,He),t(P,k),t(P,je),t(P,y)},p:$o,d(e){e&&o(p),e&&o(v),e&&o(g),e&&o(m),e&&o(E),e&&o(oe),e&&o(w),e&&o(te),e&&o(S),e&&o(le),e&&o(q),e&&o(ie),e&&o(B),e&&o(ae),e&&o(R),e&&o(re),e&&o(h),e&&o(ne),e&&o(x),e&&o(se),e&&o($),e&&o(ce),e&&o(N),e&&o(pe),e&&o(A),e&&o(ue),e&&o(O),e&&o(de),e&&o(P)}}}function Oo(b){let p,_;const v=[b[0],bo];let g={$$slots:{default:[Ao]},$$scope:{ctx:b}};for(let u=0;u<v.length;u+=1)g=Ve(g,v[u]);return p=new No({props:g}),{c(){Bo(p.$$.fragment)},l(u){Ro(p.$$.fragment,u)},m(u,m){To(p,u,m),_=!0},p(u,[m]){const E=m&1?Co(v,[m&1&&Io(u[0]),m&0&&Io(bo)]):{};m&2&&(E.$$scope={dirty:m,ctx:u}),p.$set(E)},i(u){_||(Do(p.$$.fragment,u),_=!0)},o(u){Mo(p.$$.fragment,u),_=!1},d(u){xo(p,u)}}}const bo={id:"2022-11-15-12",titolo:"Spanning-tree Protocol",featured:!1,autore:"Luca Bortoluzzi",data:"2022-11-15T00:00:00.000Z",cover:"cover_stpa.webp",introduzione:"Introduzione allo Spanning-tree Protocol",pubblicato:!0,sezione:"Blog",categorie:["Protocols","Technology","Networking","Switching"]};function Go(b,p,_){return b.$$set=v=>{_(0,p=Ve(Ve({},p),Lo(v)))},p=Lo(p),[p]}class jo extends wo{constructor(p){super(),So(this,p,Go,Oo,qo,{})}}export{jo as default,bo as metadata};
